{"version":3,"sources":["../src/EventStream.js"],"names":["yup","schema","object","shape","web3Factory","required","address","string","log","Log","component","testWeb3","web3","sub","eth","subscribe","unsubscribe","EventStream","props","validateSync","Error","abi","Array","isArray","contract","Contract","eventHistory","EventHistory","eventPuller","Puller","router","Router","errorHandler","emit","e","forEach","fn","bind","use","arguments","fromBlock","toBlock","eventName","options","lag","isNaN","pollWeb3","latest","getBlockNumber","start","span","debug","s","Date","now","recoverEvents","bundles","_handleBlockBundles","info","lastBlock","subHandler","block","number","pullEvents","length","hi","b","blockNumber","SubManager","startBlock","handler","ctx","i","process","error","EventEmitter","POLL_PERIOD","_startPoll","on","toID","clearInterval","running","poll","getBlock","setInterval"],"mappings":"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","file":"EventStream.js","sourcesContent":["import EventEmitter from 'events';\nimport Puller from 'eth-event-puller';\nimport EventHistory from './EventHistory';\nimport Router from './Router';\nimport * as yup from 'yup';\nimport Log from 'stream-logger';\nimport _ from 'lodash';\n\nconst schema = yup.object().shape({\n  web3Factory: yup.object().required(\"Missing event stream web3 factory function\"),\n  address: yup.string().required(\"Missing contract address for event stream\")\n});\n\nconst log = new Log({component: \"EventStream\"});\n\nconst testWeb3 = async web3 => {\n  let sub = this.web3.eth.subscribe(\"newBlockHeaders\");\n  await sub.unsubscribe();\n}\n\nexport default class EventStream extends EventEmitter {\n  constructor(props) {\n    super();\n    schema.validateSync(props);\n\n    //contract address to subscribe to\n    let address = props.address;\n\n    this.web3Factory = props.web3Factory;\n    if(typeof this.web3Factory !== 'function') {\n      throw new Error(\"Web3 factory is not a function\");\n    }\n\n    //abi for decoding the events\n    let abi = props.abi;\n    if(!Array.isArray(abi)) {\n      throw new Error(\"ABI is expected to be an array of field/event defs\");\n    }\n\n    //web3 for setup\n    let web3 = this.web3Factory();\n\n    //creating a contract has a side-effect of adding abi signature to every\n    //function/event definition. We need these later to extract the function\n    //context of event bundles.\n    this.contract = new web3.eth.Contract(abi, address, {address: address});\n\n    //to recover historical data\n    this.eventHistory = props.eventHistory || new EventHistory();\n\n    //to pull current events\n    this.eventPuller = props.eventPuller || new Puller();\n\n    //utility to distribute txns with bundled events\n    this.router = new Router({errorHandler: e=>this.emit(\"error\", e)});\n    [\n      'start',\n      'use',\n      'stop',\n      '_handleBlockBundles'\n    ].forEach(fn=>this[fn]=this[fn].bind(this));\n  }\n\n  use() {\n    this.router.use(...arguments);\n  }\n\n  /**\n   * Start the stream and start scanning from the fromBlock-toBlock range.\n   * Optionally provide a specific event to query, filter options, and a\n   * block lag to stay behind the top of the chain by a certain number of\n   * blocks. Historical event recovery happens first and once that is complete,\n   * event subscriptions begin and the async promise from this fn will complete.\n   *\n   * Be sure to install all router handlers before starting the stream\n   */\n  async start({\n    fromBlock,\n    toBlock,\n    eventName,\n    options,\n    lag\n  }) {\n    if(fromBlock < 0) {\n      fromBlock = 0;\n    }\n    if(isNaN(lag)) {\n      lag = 0;\n    }\n\n    let web3 = this.web3Factory();\n    //see if we can subscribe\n    try {\n      await testWeb3(web3);\n    } catch (e) {\n      this.pollWeb3 = true;\n    }\n\n    //first need to recover missed events since last run\n    let latest = toBlock;\n    if(!latest) {\n      //go to the top of the current chain by default\n      latest = await web3.eth.getBlockNumber();\n      latest -= lag;\n    }\n\n    if(latest < fromBlock) {\n      throw new Error(\"Start block must come before end block: \" + fromBlock + \" > \" + latest);\n    }\n\n    let start = fromBlock;\n    let span = latest - start;\n    log.debug(\"Scanning blocks\", start,\"-\",latest);\n    let s = Date.now();\n\n    //while there is a gap in block scanning\n    while(span > 0) {\n      //pull all events for the span\n      await this.eventHistory.recoverEvents({\n        fromBlock: start,\n        toBlock: latest,\n        eventName,\n        options,\n        contract: this.contract\n      }, (e, bundles)=>this._handleBlockBundles(e, {web3}, bundles));\n\n      log.info(\"Finished recovering batch of events...\");\n\n      //reset the start for next iteration\n      start = latest+1;\n\n      //grab the latest right now\n      latest = await web3.eth.getBlockNumber();\n      latest -= lag;\n\n      //compute new span\n      span = latest - start;\n      log.info(\"New end block is\", latest, \"and new span is\", span);\n    }\n\n    log.info(\"Finished recovering past events in\", (Date.now()-s),\"ms\");\n    let lastBlock = latest;\n\n    let subHandler = async (block)=>{\n      if(block) {\n        try {\n          log.info(\"Receiving new block\", block.number);\n          //we start from the last block we pulled so that\n          //if there are missing notifications we still pull\n          //all the data\n          let start = lastBlock+1;\n          if(start < block.number) {\n            log.debug(\"Pulling events between blocks\",start,\"-\",block.number);\n            await this.eventPuller.pullEvents({\n              fromBlock: start,\n              toBlock: block.number-lag,\n              eventName,\n              options,\n              contract: this.contract\n            }, (e, bundles)=>{\n              if(bundles.length > 0) {\n                let hi = lastBlock;\n                bundles.forEach(b=>{\n                  if(b.blockNumber > hi) {\n                    hi = b.blockNumber;\n                  }\n                });\n                lastBlock = hi;\n              }\n              this._handleBlockBundles(e, {web3}, bundles)\n            });\n          }\n        } catch (er) {\n          this.emit(\"error\", er);\n        }\n      }\n    };\n\n    this.sub = new SubManager({\n      web3Factory: this.web3Factory,\n      startBlock: lastBlock+1,\n      handler: subHandler,\n      pollWeb3: this.pollWeb3\n    });\n\n    //now subscribe to new blocks and trigger event pulls on each\n    //new block\n    this.sub.start();\n  }\n\n  async stop() {\n    if(this.sub) {\n      await this.sub.unsubscribe();\n      this.sub = null;\n    }\n  }\n\n  async _handleBlockBundles(e, ctx, bundles) {\n    if(bundles) {\n      log.debug(\"Getting\",bundles.length,\"bundles in stream callback\");\n      for(let i=0;i<bundles.length;++i) {\n        try {\n          await this.router.process(ctx, bundles[i]);\n        } catch (e) {\n          log.error(\"Problem routing bundle\", e);\n        }\n      }\n    }\n  }\n}\n\n\nconst POLL_PERIOD = 15000;\nclass SubManager {\n  constructor(props) {\n    this.web3Factory = props.web3Factory;\n    this.startBlock = props.startBlock;\n    this.pollWeb3 = props.pollWeb3;\n    this.handler = props.handler;\n    [\n      'start',\n      'unsubscribe',\n      '_startPoll'\n    ].forEach(fn=>this[fn]=this[fn].bind(this));\n  }\n\n  start() {\n    if(this.pollWeb3) {\n      return this._startPoll();\n    }\n\n    log.info(\"Using new block subscriptions\");\n    this.web3 = this.web3Factory();\n    this.sub = this.web3.eth.subscribe(\"newBlockHeaders\")\n    this.sub.on(\"data\", this.handler);\n  }\n\n  async unsubscribe() {\n    if(this.sub) {\n      await this.sub.unsubscribe();\n      this.sub = null;\n    } else if(this.toID) {\n      clearInterval(this.toID);\n      this.toID = null;\n    }\n  }\n\n  _startPoll() {\n    log.info(\"Using polling to get new blocks\");\n\n    let running = false;\n    let poll = async () => {\n\n      running = true;\n      let web3 = this.web3Factory();\n      let latest = await web3.eth.getBlockNumber();\n      try {\n        log.info(\"Getting new blocks from\", this.startBlock,\"to\",latest);\n\n        if(latest === this.startBlock) {\n          return;\n        }\n        let block = await web3.eth.getBlock(latest);\n        if(block) {\n          this.startBlock = latest;\n          try {\n            await this.handler(block);\n          } catch (e) {\n            log.error(\"Problem calling subscription handler\", e);\n          }\n        }\n\n        /*\n        for(let i=this.startBlock;i<=latest;++i) {\n          let block = await web3.eth.getBlock(i);\n          this.startBlock = i+1;\n          try {\n            await this.handler(block);\n          } catch (e) {\n            log.error(\"Problem calling subscription handler\", e);\n          }\n        }\n        */\n      } finally {\n        running = false;\n      }\n    }\n\n    this.toID = setInterval(async ()=>{\n      if(!running) {\n        await poll()\n      }\n    }, POLL_PERIOD);\n  }\n}\n"]}