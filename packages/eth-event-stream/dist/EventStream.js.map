{"version":3,"sources":["../src/EventStream.js"],"names":["yup","schema","object","shape","web3Factory","required","address","string","log","Log","component","testWeb3","web3","sub","eth","subscribe","unsubscribe","EventStream","props","validateSync","Error","abi","Array","isArray","contract","Contract","eventHistory","EventHistory","eventPuller","Puller","router","Router","errorHandler","emit","e","forEach","fn","bind","use","arguments","include","fnParser","FnContextParser","fromBlock","toBlock","eventName","options","lag","isNaN","pollWeb3","latest","getBlockNumber","start","span","debug","s","Date","now","recoverEvents","txns","_handleTransactions","info","lastBlock","subHandler","block","number","pullEvents","length","hi","t","blockNumber","SubManager","startBlock","handler","ctx","i","getTransaction","transactionHash","fullTxn","parse","input","fnContext","process","error","EventEmitter","POLL_PERIOD","_startPoll","on","toID","clearInterval","running","poll","getBlock","setInterval","fnSigs","a","type","signature","sig","substring","def","name"],"mappings":"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","file":"EventStream.js","sourcesContent":["import EventEmitter from 'events';\nimport {StatelessEventPuller as Puller} from 'eth-event-puller';\nimport EventHistory from './EventHistory';\nimport Router from './Router';\nimport * as yup from 'yup';\nimport Log from 'stream-logger';\nimport _ from 'lodash';\n\nconst schema = yup.object().shape({\n  web3Factory: yup.object().required(\"Missing event stream web3 factory function\"),\n  address: yup.string().required(\"Missing contract address for event stream\")\n});\n\nconst log = new Log({component: \"EventStream\"});\n\nconst testWeb3 = async web3 => {\n  let sub = this.web3.eth.subscribe(\"newBlockHeaders\");\n  await sub.unsubscribe();\n}\n\nexport default class EventStream extends EventEmitter {\n  constructor(props) {\n    super();\n    schema.validateSync(props);\n\n    //contract address to subscribe to\n    let address = props.address;\n\n    this.web3Factory = props.web3Factory;\n    if(typeof this.web3Factory !== 'function') {\n      throw new Error(\"Web3 factory is not a function\");\n    }\n\n    //abi for decoding the events\n    let abi = props.abi;\n    if(!Array.isArray(abi)) {\n      throw new Error(\"ABI is expected to be an array of field/event defs\");\n    }\n\n    this.abi = abi;\n\n    //web3 for setup\n    let web3 = this.web3Factory();\n\n    //creating a contract has a side-effect of adding abi signature to every\n    //function/event definition. We need these later to extract the function\n    //context of event bundles.\n    this.contract = new web3.eth.Contract(abi, address, {address: address});\n\n    //to recover historical data\n    this.eventHistory = props.eventHistory || new EventHistory();\n\n    //to pull current events\n    this.eventPuller = props.eventPuller || new Puller();\n\n    //utility to distribute txns with bundled events\n    this.router = new Router({errorHandler: e=>this.emit(\"error\", e)});\n    [\n      'start',\n      'use',\n      'stop',\n      'withFunctionContext',\n      '_handleTransactions'\n    ].forEach(fn=>this[fn]=this[fn].bind(this));\n  }\n\n  use() {\n    this.router.use(...arguments);\n  }\n\n  withFunctionContext(include) {\n    this.fnParser = new FnContextParser(this.abi);\n    return this;\n  }\n\n  /**\n   * Start the stream and start scanning from the fromBlock-toBlock range.\n   * Optionally provide a specific event to query, filter options, and a\n   * block lag to stay behind the top of the chain by a certain number of\n   * blocks. Historical event recovery happens first and once that is complete,\n   * event subscriptions begin and the async promise from this fn will complete.\n   *\n   * Be sure to install all router handlers before starting the stream\n   */\n  async start({\n    fromBlock,\n    toBlock,\n    eventName,\n    options,\n    lag\n  }) {\n    if(fromBlock < 0) {\n      fromBlock = 0;\n    }\n    if(isNaN(lag)) {\n      lag = 0;\n    }\n\n    let web3 = this.web3Factory();\n    //see if we can subscribe\n    try {\n      await testWeb3(web3);\n    } catch (e) {\n      this.pollWeb3 = true;\n    }\n\n    //first need to recover missed events since last run\n    let latest = toBlock;\n    if(!latest) {\n      //go to the top of the current chain by default\n      latest = await web3.eth.getBlockNumber();\n      latest -= lag;\n    }\n\n    if(latest < fromBlock) {\n      throw new Error(\"Start block must come before end block: \" + fromBlock + \" > \" + latest);\n    }\n\n    let start = fromBlock;\n    let span = latest - start;\n    log.debug(\"Scanning blocks\", start,\"-\",latest);\n    let s = Date.now();\n\n    //while there is a gap in block scanning\n    while(span > 0) {\n      //pull all events for the span\n      await this.eventHistory.recoverEvents({\n        fromBlock: start,\n        toBlock: latest,\n        eventName,\n        options,\n        contract: this.contract\n      }, (e, txns)=>this._handleTransactions(e, {web3}, txns));\n\n      log.info(\"Finished recovering batch of events...\");\n\n      //reset the start for next iteration\n      start = latest+1;\n\n      //grab the latest right now\n      latest = await web3.eth.getBlockNumber();\n      latest -= lag;\n\n      //compute new span\n      span = latest - start;\n      log.info(\"New end block is\", latest, \"and new span is\", span);\n    }\n\n    log.info(\"Finished recovering past events in\", (Date.now()-s),\"ms\");\n    let lastBlock = latest;\n\n    let subHandler = async (block)=>{\n      if(block) {\n        try {\n          log.info(\"Receiving new block\", block.number);\n          //we start from the last block we pulled so that\n          //if there are missing notifications we still pull\n          //all the data\n          let start = lastBlock+1;\n          if(start < block.number) {\n            log.debug(\"Pulling events between blocks\",start,\"-\",block.number);\n            await this.eventPuller.pullEvents({\n              fromBlock: start,\n              toBlock: block.number-lag,\n              eventName,\n              options,\n              contract: this.contract\n            }, (e, txns)=>{\n              if(txns.length > 0) {\n                let hi = lastBlock;\n                txns.forEach(t=>{\n                  if(t.blockNumber > hi) {\n                    hi = t.blockNumber;\n                  }\n                });\n                lastBlock = hi;\n              }\n              this._handleTransactions(e, {web3}, txns)\n            });\n          }\n        } catch (er) {\n          this.emit(\"error\", er);\n        }\n      }\n    };\n\n    this.sub = new SubManager({\n      web3Factory: this.web3Factory,\n      startBlock: lastBlock+1,\n      handler: subHandler,\n      pollWeb3: this.pollWeb3\n    });\n\n    //now subscribe to new blocks and trigger event pulls on each\n    //new block\n    this.sub.start();\n  }\n\n  async stop() {\n    if(this.sub) {\n      await this.sub.unsubscribe();\n      this.sub = null;\n    }\n  }\n\n  async _handleTransactions(e, ctx, txns) {\n    if(txns) {\n      log.debug(\"Getting\",txns.length,\"txns in stream callback\");\n      for(let i=0;i<txns.length;++i) {\n        let t = txns[i];\n\n        if(this.fnParser) {\n          let fullTxn = await ctx.web3.eth.getTransaction(t.transactionHash);\n          if(fullTxn) {\n            let fn = this.fnParser.parse(fullTxn.input);\n            t.fnContext = fn;\n          }\n        }\n\n        try {\n          await this.router.process(ctx, t);\n        } catch (e) {\n          log.error(\"Problem routing bundle\", e);\n        }\n      }\n    }\n  }\n}\n\n\nconst POLL_PERIOD = 15000;\nclass SubManager {\n  constructor(props) {\n    this.web3Factory = props.web3Factory;\n    this.startBlock = props.startBlock;\n    this.pollWeb3 = props.pollWeb3;\n    this.handler = props.handler;\n    [\n      'start',\n      'unsubscribe',\n      '_startPoll'\n    ].forEach(fn=>this[fn]=this[fn].bind(this));\n  }\n\n  start() {\n    if(this.pollWeb3) {\n      return this._startPoll();\n    }\n\n    log.info(\"Using new block subscriptions\");\n    this.web3 = this.web3Factory();\n    this.sub = this.web3.eth.subscribe(\"newBlockHeaders\")\n    this.sub.on(\"data\", this.handler);\n  }\n\n  async unsubscribe() {\n    if(this.sub) {\n      await this.sub.unsubscribe();\n      this.sub = null;\n    } else if(this.toID) {\n      clearInterval(this.toID);\n      this.toID = null;\n    }\n  }\n\n  _startPoll() {\n    log.info(\"Using polling to get new blocks\");\n\n    let running = false;\n    let poll = async () => {\n\n      running = true;\n      let web3 = this.web3Factory();\n      let latest = await web3.eth.getBlockNumber();\n      try {\n        log.info(\"Getting new blocks from\", this.startBlock,\"to\",latest);\n\n        if(latest === this.startBlock) {\n          return;\n        }\n        let block = await web3.eth.getBlock(latest);\n        if(block) {\n          this.startBlock = latest;\n          try {\n            await this.handler(block);\n          } catch (e) {\n            log.error(\"Problem calling subscription handler\", e);\n          }\n        }\n\n        /*\n        for(let i=this.startBlock;i<=latest;++i) {\n          let block = await web3.eth.getBlock(i);\n          this.startBlock = i+1;\n          try {\n            await this.handler(block);\n          } catch (e) {\n            log.error(\"Problem calling subscription handler\", e);\n          }\n        }\n        */\n      } finally {\n        running = false;\n      }\n    }\n\n    this.toID = setInterval(async ()=>{\n      if(!running) {\n        await poll()\n      }\n    }, POLL_PERIOD);\n  }\n}\n\nclass FnContextParser {\n  constructor(abi) {\n    this.fnSigs = {};\n    abi.forEach(a=>{\n      if(a.type === 'function') {\n        this.fnSigs[a.signature] = a;\n      }\n    });\n    [\n      'parse'\n    ].forEach(fn=>this[fn]=this[fn].bind(this));\n  }\n\n  parse(input) {\n    if(input && input.length > 2) {\n      let sig = input.substring(0, 10);\n      let def = this.fnSigs[sig];\n      if(def) {\n        return def.name;\n      } else {\n        return sig;\n      }\n    }\n  }\n}\n"]}