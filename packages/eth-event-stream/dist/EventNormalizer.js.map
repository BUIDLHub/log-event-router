{"version":3,"sources":["../src/EventNormalizer.js"],"names":["yup","schema","object","shape","web3Factory","required","log","Log","component","EventNormalizer","props","abi","fnSigs","Array","isArray","Error","forEach","a","type","signature","fn","bind","ctx","event","retVals","returnValues","history","_","keys","d","k","_ethersType","toString","txn","transactionHash","toLowerCase","web3","start","Date","now","debug","eth","getTransaction","hash","input","length","sig","substring","def","fnContext","name","logEvents","le","ex","push","sort","b","logIndex"],"mappings":"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","file":"EventNormalizer.js","sourcesContent":["import * as yup from 'yup';\nimport _ from 'lodash';\nimport Log from 'stream-logger';\n\nconst schema = yup.object().shape({\n  web3Factory: yup.object().required(\"Event normalizer requires a web3Factory function\"),\n});\n\nconst log = new Log({component: \"EventNormalizer\"});\n\nexport default class EventNormalizer {\n  constructor(props) {\n    this.web3Factory = props.web3Factory;\n    let abi = props.abi;\n    this.fnSigs = {};\n\n\n    if(!Array.isArray(abi)) {\n      throw new Error(\"Event normalizer requires abi array of event/function definitions\");\n    }\n\n    abi.forEach(a=>{\n      if(a.type === 'function') {\n        if(a.signature) {\n          this.fnSigs[a.signature] = a;\n        }\n      }\n    });\n\n    [\n      'normalize'\n    ].forEach(fn=>this[fn]=this[fn].bind(this));\n  }\n\n  async normalize(ctx, event) {\n    let retVals = event.returnValues;\n    if(!retVals) {\n      return;\n    }\n    let history = ctx.history;\n\n    //convert big numbers to strings to simplify working with event fields\n    _.keys(retVals).forEach(k=>{\n      let d = retVals[k];\n      if(d._ethersType === 'BigNumber') {\n        retVals[k] = d.toString();\n      }\n    });\n\n    let txn = history[event.transactionHash.toLowerCase()];\n\n    let web3 = ctx.web3;\n\n    if(!txn) {\n      let start = Date.now();\n      log.debug(\"Pulling txn: \" + event.transactionHash);\n      txn = await web3.eth.getTransaction(event.transactionHash);\n      log.debug(\"Retrieved txn in \", (Date.now()-start),\"ms\");\n      if(txn) {\n        history[txn.hash.toLowerCase()] = txn;\n\n        if(txn.input && txn.input.length > 2) {\n\n          //get the fn signature (4-bytes plus 0x)\n          let sig = txn.input.substring(0, 10);\n\n          //lookup the fn definition by this sig\n          let def = this.fnSigs[sig];\n          if(def) {\n            //if we found a matching fn, tag the transaction with the\n            //fn's name. This will be used downstream as a context for\n            //all attached log events\n            txn.fnContext = def.name;\n          } else {\n            txn.fnContext = sig;\n          }\n        } else {\n          txn.fnContext = \"no_input\";\n        }\n        txn.logEvents = {};\n      }\n    }\n    if(txn) {\n      let le = {\n        ...txn.logEvents\n      };\n      let ex = le[event.event];\n      if(ex) {\n        let a = null;\n        if(!Array.isArray(ex)) {\n          a = [ex];\n        } else {\n          a = ex;\n        }\n\n        a.push(event);\n        a.sort((a,b)=>a.logIndex-b.logIndex);\n\n        le[event.event] = a;\n      } else {\n        le[event.event] = event;\n      }\n      txn.logEvents = le;\n    }\n  }\n}\n"]}