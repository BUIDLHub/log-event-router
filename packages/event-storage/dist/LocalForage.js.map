{"version":3,"sources":["../src/LocalForage.js"],"names":["localforage","dbFactory","props","createInstance","name","db","_buildSortFn","sort","field","order","sorter","set","fld","isAsc","a","b","av","bv","forEach","s","toUpperCase","inst","LocalForage","querySizeLimit","fn","bind","dbs","console","log","dropInstance","undefined","storeSchema","validateSync","_getDB","setItem","key","data","database","storeBulkSchema","setItems","items","readSchema","getItem","r","readAllSchema","sortFn","limit","filterFn","iterate","v","k","itNum","push","iterateSchema","callback","Error","findSchema","selKeys","_","keys","selector","offset","includeTotal","skipping","endLength","total","dbVal","dbKey","allMatch","i","length","p","tgt","isNaN","updateSchema","removeSchema","BaseDB"],"mappings":"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","file":"LocalForage.js","sourcesContent":["import localforage from 'localforage';\nimport {extendPrototype} from 'localforage-setitems';\nimport BaseDB, {\n  storeSchema,\n  storeBulkSchema,\n  readSchema,\n  readAllSchema,\n  findSchema,\n  updateSchema,\n  removeSchema,\n  iterateSchema\n} from './BaseDB';\nimport _ from 'lodash';\n\nextendPrototype(localforage);\n\nconst dbFactory = async props => {\n  var db = await localforage.createInstance({\n    name: props.name\n  });\n  return db;\n}\n\nconst _buildSortFn = props => {\n  if(!props.sort) {\n    props.sort = [\n      {\n        field: \"blockNumber\",\n        order: \"desc\"\n      }\n    ];\n  }\n\n  let sorter = (set, fld, isAsc) => {\n    set.sort((a,b)=>{\n      let av = a[fld];\n      let bv = b[fld];\n      if(av > bv) {\n        return isAsc ? 1 : -1;\n      }\n      if(av < bv) {\n        return isAsc ? -1 : 1;\n      }\n      return 0;\n    });\n  };\n  return set => {\n    props.sort.forEach(s=>{\n      sorter(set, s.field, s.order.toUpperCase() === 'ASC')\n    });\n  }\n}\n\nlet inst = null;\nexport default class LocalForage extends BaseDB {\n  static get instance() {\n    if(!inst) {\n      inst = new LocalForage();\n    }\n    return inst;\n  }\n\n  constructor(props) {\n    super(props);\n    this.querySizeLimit = props?props.querySizeLimit || 50:50;\n\n    [\n      'store',\n      'storeBulk',\n      'read',\n      'readAll',\n      'find',\n      'update',\n      'remove',\n      'removeDB',\n      'iterate'\n    ].forEach(fn=>{\n      this[fn]=this[fn].bind(this)\n    });\n  }\n\n  async removeDB(name) {\n    let db = this.dbs[name];\n    if(!db) {\n      return;\n    }\n    console.log(\"Dropping DB\", name);\n    db.dropInstance();\n    this.dbs[name] = undefined;\n  }\n\n  async store(props) {\n    storeSchema.validateSync(props);\n    let db = await this._getDB(props, dbFactory);\n    try {\n      await db.setItem(props.key, props.data);\n    } catch (e) {\n      console.log(\"Problem storing to\", props.database, e);\n    }\n\n  }\n\n  async storeBulk(props) {\n    storeBulkSchema.validateSync(props);\n    let db = await this._getDB(props, dbFactory);\n    try {\n      await db.setItems(props.items);\n    } catch (e) {\n      console.log(\"Problem storing items\", props.database, e);\n    }\n  }\n\n  async read(props) {\n    readSchema.validateSync(props);\n    let db = await this._getDB(props, dbFactory);\n    let r = await db.getItem(props.key);\n    return r ? [r] : [];\n  }\n\n  async readAll(props) {\n    readAllSchema.validateSync(props);\n    let db = await this._getDB(props, dbFactory);\n\n    let set = [];\n    let sortFn = _buildSortFn(props);\n    let limit = props.limit || this.querySizeLimit;\n    let filterFn = props.filterFn;\n    await db.iterate((v, k, itNum)=>{\n      if(itNum > limit) {\n        return set;\n      }\n      if(filterFn) {\n        if(filterFn(v, k, itNum)) {\n          set.push(v);\n        }\n      } else {\n        set.push(v);\n      }\n    });\n    if(sortFn) {\n      sortFn(set);\n    }\n    return set;\n  }\n\n  async iterate(props) {\n    iterateSchema.validateSync(props);\n    if(typeof props.callback !== 'function') {\n      throw new Error(\"Missing callback function\");\n    }\n    let db = await this._getDB(props, dbFactory);\n    await db.iterate(props.callback);\n  }\n\n  async find(props) {\n    findSchema.validateSync(props);\n    let db = await this._getDB(props, dbFactory);\n    let set = [];\n    let sortFn = _buildSortFn(props);\n    let limit = props.limit || this.querySizeLimit;\n    let selKeys = _.keys(props.selector);\n    let offset = props.offset || 0;\n    let includeTotal = props.includeTotal;\n    let skipping = offset > 0;\n    let endLength = offset + limit;\n\n    let total = 0;\n    await db.iterate((dbVal, dbKey, itNum)=>{\n      let allMatch = true;\n      //filter based on selectors first. This way we make\n      //sure paging and sorting work with the same dataset\n      //each time. This is terribly slow but localforage/indexedDB\n      //doesn't offer skipping records. An optimization might be\n      //to keep our own index of record counts so that at a minimum\n      //we're not running through entire set each time. Skipping would\n      //still require walk from beginning. I don't know what happens if\n      //records are inserted during paging operation...would we miss an\n      //item if it's key were iterated earlier than the page we skipped?\n      //This needs more thought.\n      for(let i=0;i<selKeys.length;++i) {\n        let p = selKeys[i];\n        let tgt = props.selector[p];\n        let v = dbVal[p];\n        if(!isNaN(v) && !isNaN(tgt)) {\n          v -= 0;\n          tgt -= 0;\n        }\n        if(v !== tgt) {\n          allMatch = false;\n          break;\n        }\n      }\n      if(allMatch) {\n        ++total;\n        if(!skipping && set.length < endLength) {\n          set.push(dbVal);\n        } else if(!skipping && set.length >= endLength && !includeTotal) {\n          return set;\n        }\n      }\n\n      skipping = total < offset || set.length > (offset+limit);\n    });\n\n    if(sortFn) {\n      sortFn(set);\n    }\n    if(includeTotal) {\n      return {\n        total,\n        data: set\n      }\n    }\n    return set;\n  }\n\n  async update(props) {\n    updateSchema.validateSync(props);\n  }\n\n  async remove(props) {\n    removeSchema.validateSync(props);\n  }\n}\n"]}