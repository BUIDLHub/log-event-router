{"version":3,"sources":["../src/index.js"],"names":["log","Log","component","TxnBundler","props","forEach","fn","bind","ctx","Promise","done","err","bundle","length","web3","hash","transactionHash","toLowerCase","txn","debug","_getTxn","warn","cb","error","attempt","maxTries","_recursiveGetTxn","e","eth","getTransaction","ctx2"],"mappings":"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","file":"index.js","sourcesContent":["import Log from 'stream-logger';\nimport _ from 'lodash';\n\nconst log = new Log({component: \"TxnBundler\"});\n\nexport default class TxnBundler {\n  constructor(props) {\n    [\n      'process',\n      '_getTxn'\n    ].forEach(fn=>this[fn]=this[fn].bind(this));\n  }\n\n  process(ctx) {\n    return new Promise(async (done,err)=>{\n      let bundle = ctx.bundle;\n\n      if(bundle.length === 0) {\n        return done(bundle);\n      }\n\n      let web3 = ctx.web3;\n      let hash = bundle.transactionHash.toLowerCase();\n\n      let txn = null;\n      try {\n        log.debug(\"Requesting txn with hash\", hash);\n        txn = await this._getTxn({web3, hash});\n        log.debug(\"Txn result\", txn);\n      } catch (e) {\n        return err(e);\n      }\n\n      if(!txn) {\n        log.warn(\"Missing txn with hash\", hash);\n        return done(bundle);\n      }\n      bundle.txn = txn;\n      done(bundle);\n    });\n\n  }\n\n  _getTxn({web3, hash}) {\n    let cb = async (done,err) => {\n      try {\n        let ctx = {\n          done,\n          error: err,\n          web3,\n          hash,\n          attempt: 1,\n          maxTries: 10\n        };\n        _recursiveGetTxn(ctx);\n      } catch (e) {\n        err(e);\n      }\n    }\n\n    return new Promise(cb);\n  }\n}\n\nconst _recursiveGetTxn = async ctx => {\n  try {\n    let txn = await ctx.web3.eth.getTransaction(ctx.hash);\n    if(!txn) {\n      if(ctx.attempt >= ctx.maxTries) {\n        return ctx.error(\"Giving up on txn after \" + ctx.maxTries + \" attempts\");\n      }\n      let ctx2 = {\n        ...ctx,\n        attempt: ctx.attempt + 1\n      };\n      _recursiveGetTxn(ctx2);\n    } else {\n      ctx.done(txn);\n    }\n  } catch (e) {\n    if(ctx.attempt >= ctx.maxTries) {\n      return ctx.error(e);\n    }\n    let ctx2 = {\n      ...ctx,\n      attempt: ctx.attempt + 1\n    };\n    _recursiveGetTxn(ctx2);\n  }\n}\n"]}