{"version":3,"sources":["../src/StatefulEventPuller.js"],"names":["log","Log","component","StatefulEventPuller","props","forEach","fn","bind","cb","cursor","Cursor","init","fromBlock","toBlock","finalEnd","increment","contract","eventName","options","totalPages","Promise","done","err","_pull","span","error","undefined","info","config","evtName","start","Date","now","getPastEvents","events","sort","a","b","diff","blockNumber","transactionIndex","byBlock","byBlockAndHash","length","blocks","_","values","debug","i","transactions","end","message","includes","newSpan","Math","ceil","totalSpan","finalBlock","reduce","o","e","retVals","returnValues","keys","d","k","_ethersType","toString","block","EthBlock","number","addEvent"],"mappings":"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","file":"StatefulEventPuller.js","sourcesContent":["import Log from 'stream-logger';\nimport EthBlock from 'eth-data';\nimport _ from 'lodash';\n\nconst log = new Log({component: \"StatefulEventPuller\"});\n\nexport default class StatefulEventPuller {\n  constructor(props) {\n    [\n      'pullEvents'\n    ].forEach(fn=>this[fn]=this[fn].bind(this));\n  }\n\n  pullEvents(props, cb) {\n    let cursor = new Cursor(props);\n    return cursor.init(cb);\n  }\n}\n\n\nclass Cursor {\n  constructor(props) {\n    this.fromBlock = props.fromBlock;\n    this.toBlock = props.toBlock;\n    this.finalEnd = props.toBlock;\n    this.increment = 0;\n    this.contract = props.contract;\n    this.eventName = props.eventName;\n    this.options = props.options;\n    this.totalPages = 1;\n\n    [\n      'init',\n      'nextBatch',\n      '_pull'\n    ].forEach(fn=>this[fn]=this[fn].bind(this));\n  }\n\n  async init(cb) {\n    return new Promise((done,err)=>{\n      this._pull(done, err, cb);\n    });\n  }\n\n  async nextBatch(cb) {\n    return new Promise((done,err)=>{\n      this._pull(done, err, cb);\n    })\n  }\n\n  async _pull(done, err, cb) {\n    let span = this.toBlock - this.fromBlock;\n    if(span < 0) {\n      log.error(\"Invalid block range. Start is before end\", this.fromBlock, this.toBlock);\n      //return err(new Error(\"Start block is after end block\"));\n      return done(undefined);\n    }\n\n    log.info(\"Querying for logs in range\", this.fromBlock, \"-\", this.toBlock);\n    let config = {\n      ...this.options,\n      fromBlock: this.fromBlock,\n      toBlock: this.toBlock\n    };\n\n    try {\n      let contract = this.contract;\n\n      let evtName = this.eventName || \"allEvents\";\n      let start = Date.now();\n      let events = await contract.getPastEvents(evtName, config);\n\n      //always make sure events are sorted by block and txn index\n      events.sort((a,b)=>{\n        let diff = a.blockNumber - b.blockNumber;\n        if(diff) {\n          return diff;\n        }\n        return a.transactionIndex - b.transactionIndex;\n      });\n\n      //convert to consistent block structure\n      let byBlock = byBlockAndHash(events);\n\n      log.info(\"Retrieved\", events.length, \"events in\", (Date.now()-start),\"ms\");\n\n      try {\n\n        let blocks = _.values(byBlock);\n        log.debug(\"Sending\", blocks.length, \"blocks to callback\");\n        //for each block\n        for(let i=0;i<blocks.length;++i) {\n          let b = blocks[i];\n          //send back all transaction bundles\n          await cb(null, b.transactions);\n        }\n      } catch (e) {\n        log.error(\"Problem in callback\", e);\n      }\n\n      //if there is more in the entire block range\n      log.debug(\"Final end\",this.finalEnd,\"Current end\",this.toBlock);\n      if(this.finalEnd > this.toBlock) {\n        let start = this.toBlock + 1;\n        let end = this.toBlock + 1 + this.increment;\n        log.debug(\"Going to next segement\", start, end);\n        this.fromBlock = start;\n        this.toBlock = end;\n        done(this);\n      } else {\n        log.debug(\"Finished all segments\");\n        //otherwise scan is complete\n        done(undefined);\n      }\n    } catch (e) {\n\n\n      //yes, hacky, but Infura docs specific have this as what to look\n      //for to adjust block range\n      if(e.message.includes(\"more than 1000 results\")) {\n        log.info(\"Have to split query apart\");\n        if(span <= 1) {\n          //we've already reduced it as much as we can reduce\n          //the span so have to bail out.\n          throw e;\n        }\n        //otherwise, cut the span in 1/2 and try again\n        let newSpan = Math.ceil(span/2);\n\n        //if wec can't split any lower than 1, we bail\n        if(newSpan === 0) {\n          throw e;\n        }\n\n        let totalSpan = this.finalBlock - this.fromBlock;\n\n        this.increment = newSpan;\n        this.totalPages = Math.ceil(totalSpan / this.increment);\n        this.toBlock = newSpan + this.fromBlock;\n        this._pull(done, err, cb);\n      } else {\n        log.error(\"Problem pulling events\", e);\n        err(e);\n      }\n    }\n  }\n}\n\nconst byBlockAndHash = (events) => {\n  return events.reduce((o,e)=>{\n    let retVals = e.returnValues;\n    _.keys(retVals).forEach(k=>{\n      let d = retVals[k];\n      if(d._ethersType === 'BigNumber') {\n        retVals[k] = d.toString();\n      }\n    });\n    let block = o[e.blockNumber] || new EthBlock({\n      number: e.blockNumber\n    });\n    block.addEvent(e);\n    o[e.blockNumber] = block;\n    return o;\n  },{});\n}\n"]}