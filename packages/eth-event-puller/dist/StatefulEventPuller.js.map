{"version":3,"sources":["../src/StatefulEventPuller.js"],"names":["log","Log","component","MIN_BLOCK_RANGE","StatefulEventPuller","props","forEach","fn","bind","cb","cursor","Cursor","init","fromBlock","toBlock","finalEnd","increment","contract","eventName","options","totalPages","meta","rpcCalls","Promise","done","err","_pull","span","error","undefined","info","config","evtName","start","Date","now","getPastEvents","events","sort","a","b","diff","blockNumber","transactionIndex","byBlock","byBlockAndHash","length","blocks","_","values","debug","i","transactions","end","Math","min","message","includes","newSpan","ceil","totalSpan","finalBlock","reduce","o","e","retVals","returnValues","keys","d","k","_ethersType","toString","block","EthBlock","number","addEvent"],"mappings":"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","file":"StatefulEventPuller.js","sourcesContent":["import Log from 'stream-logger';\nimport EthBlock from 'eth-data';\nimport _ from 'lodash';\n\nconst log = new Log({component: \"StatefulEventPuller\"});\n\nconst MIN_BLOCK_RANGE = 100;\n\nexport default class StatefulEventPuller {\n  constructor(props) {\n    [\n      'pullEvents'\n    ].forEach(fn=>this[fn]=this[fn].bind(this));\n  }\n\n  pullEvents(props, cb) {\n    let cursor = new Cursor(props);\n    return cursor.init(cb);\n  }\n}\n\n\nclass Cursor {\n  constructor(props) {\n    this.fromBlock = props.fromBlock;\n    this.toBlock = props.toBlock;\n    this.finalEnd = props.toBlock;\n    this.increment = 0;\n    this.contract = props.contract;\n    this.eventName = props.eventName;\n    this.options = props.options;\n    this.totalPages = 1;\n    this.meta = {\n      rpcCalls: 0,\n      fromBlock: 0,\n      toBlock: 0\n    };\n\n    [\n      'init',\n      'nextBatch',\n      '_pull'\n    ].forEach(fn=>this[fn]=this[fn].bind(this));\n  }\n\n  async init(cb) {\n    return new Promise((done,err)=>{\n      this._pull(done, err, cb);\n    });\n  }\n\n  async nextBatch(cb) {\n    return new Promise((done,err)=>{\n      this._pull(done, err, cb);\n    })\n  }\n\n  async _pull(done, err, cb) {\n    let span = this.toBlock - this.fromBlock;\n\n    if(span < 0) {\n      log.error(\"Invalid block range. Start is before end\", this.fromBlock, this.toBlock);\n      //return err(new Error(\"Start block is after end block\"));\n      return done(undefined);\n    }\n\n    log.info(\"Querying\", span, \"blocks for logs in range\", this.fromBlock, \"-\", this.toBlock);\n    let config = {\n      ...this.options,\n      fromBlock: this.fromBlock,\n      toBlock: this.toBlock\n    };\n\n    try {\n      let contract = this.contract;\n\n      let evtName = this.eventName || \"allEvents\";\n      let start = Date.now();\n      this.meta.rpcCalls++;\n      this.meta.fromBlock = this.fromBlock;\n      this.meta.toBlock = this.toBlock;\n      let events = await contract.getPastEvents(evtName, config);\n\n      //always make sure events are sorted by block and txn index\n      events.sort((a,b)=>{\n        let diff = a.blockNumber - b.blockNumber;\n        if(diff) {\n          return diff;\n        }\n        return a.transactionIndex - b.transactionIndex;\n      });\n\n      //convert to consistent block structure\n      let byBlock = byBlockAndHash(events);\n\n      log.info(\"Retrieved\", events.length, \"events in\", (Date.now()-start),\"ms\");\n\n      try {\n\n        let blocks = _.values(byBlock);\n        log.debug(\"Sending\", blocks.length, \"blocks to callback\");\n        let meta = {\n          ...this.meta\n        };\n        for(let i=0;i<blocks.length;++i) {\n          let b = blocks[i];\n          //send back all transaction bundles\n\n          await cb(null, b.transactions, meta);\n        }\n        this.meta = {\n          rpcCalls: 0\n        }\n      } catch (e) {\n        log.error(\"Problem in callback\", e);\n      }\n\n      //if there is more in the entire block range\n      log.debug(\"Final end\",this.finalEnd,\"Current end\",this.toBlock);\n      if(this.finalEnd > this.toBlock) {\n        let start = this.toBlock + 1;\n        if(this.increment < MIN_BLOCK_RANGE) {\n          this.increment = MIN_BLOCK_RANGE;\n        }\n        let end = this.toBlock + 1 + this.increment;\n\n        log.debug(\"Going to next segement\", start, end);\n        this.fromBlock = start;\n        this.toBlock = Math.min(end, this.finalEnd);\n        done(this);\n      } else {\n        log.debug(\"Finished all segments\");\n        //otherwise scan is complete\n        done(undefined);\n      }\n    } catch (e) {\n\n\n      //yes, hacky, but Infura docs specific have this as what to look\n      //for to adjust block range\n      if(e.message.includes(\"more than 1000 results\")) {\n\n        if(span <= 1) {\n          //we've already reduced it as much as we can reduce\n          //the span so have to bail out.\n          throw e;\n        }\n\n        //otherwise, cut the span in 1/2 and try again\n        let newSpan = Math.ceil(span/2)-0;\n\n        //if wec can't split any lower than 1, we bail\n        if(newSpan === 0) {\n          throw e;\n        }\n\n        log.info(\"Have to split query apart\", span, newSpan);\n        let totalSpan = this.finalBlock - this.fromBlock;\n\n        this.increment = newSpan;\n        this.totalPages = Math.ceil(totalSpan / this.increment);\n        this.toBlock = newSpan + this.fromBlock;\n        this._pull(done, err, cb);\n      } else {\n        log.error(\"Problem pulling events\", e);\n        err(e);\n      }\n    }\n  }\n}\n\nconst byBlockAndHash = (events) => {\n  return events.reduce((o,e)=>{\n    let retVals = e.returnValues;\n    _.keys(retVals).forEach(k=>{\n      let d = retVals[k];\n      if(d._ethersType === 'BigNumber') {\n        retVals[k] = d.toString();\n      }\n    });\n    let block = o[e.blockNumber] || new EthBlock({\n      number: e.blockNumber\n    });\n    block.addEvent(e);\n    o[e.blockNumber] = block;\n    return o;\n  },{});\n}\n"]}