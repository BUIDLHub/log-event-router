{"version":3,"sources":["../src/StatelessEventPuller.js"],"names":["log","Log","component","StatelessEventPuller","props","forEach","fn","bind","cb","fromBlock","toBlock","contract","eventName","options","Promise","done","err","ctx","start","end","increment","finalEnd","_doPull","span","error","info","config","evtName","Date","now","getPastEvents","events","sort","a","b","diff","blockNumber","transactionIndex","byBlock","byBlockAndHash","length","blocks","_","values","debug","i","transactions","next","Math","ceil","message","includes","newSpan","reduce","o","e","retVals","returnValues","keys","d","k","_ethersType","toString","block","EthBlock","number","addEvent"],"mappings":";;;;;;;;;;AAAA;;;;AACA;;;;AACA;;;;;;;;;;AAEA,IAAMA,MAAM,IAAIC,sBAAJ,CAAQ,EAACC,WAAW,sBAAZ,EAAR,CAAZ;;IAEqBC,oB;AACnB,gCAAYC,KAAZ,EAAmB;AAAA;;AAAA;;AACjB,KACE,YADF,EAEE,SAFF,EAGEC,OAHF,CAGU;AAAA,aAAI,MAAKC,EAAL,IAAS,MAAKA,EAAL,EAASC,IAAT,CAAc,KAAd,CAAb;AAAA,KAHV;AAID;;;;qCAQEC,E,EAAI;AAAA;;AAAA,UALLC,SAKK,QALLA,SAKK;AAAA,UAJLC,OAIK,QAJLA,OAIK;AAAA,UAHLC,QAGK,QAHLA,QAGK;AAAA,UAFLC,SAEK,QAFLA,SAEK;AAAA,UADLC,OACK,QADLA,OACK;;AACL,aAAO,IAAIC,OAAJ,CAAY,UAACC,IAAD,EAAMC,GAAN,EAAY;AAC7B,YAAIC,MAAM;AACR;AACAC,iBAAOT,SAFC;;AAIR;AACAU,eAAKT,OALG;;AAOR;AACAE,8BARQ;;AAUR;AACAC,0BAXQ;;AAaR;AACAF,4BAdQ;;AAgBR;AACAI,oBAjBQ;;AAmBR;AACAC,kBApBQ;;AAsBR;AACAI,qBAAW,CAvBH;;AAyBR;AACAC,oBAAUX;AA1BF,SAAV;;AA6BA,eAAKY,OAAL,CAAaL,GAAb,EAAkBT,EAAlB;AACD,OA/BM,CAAP;AAgCD;;;;2FAEaS,G,EAAKT,E;;;;;;AACbe,oB,GAAON,IAAIE,GAAJ,GAAUF,IAAIC,K;;sBACtBK,OAAO,C;;;;;AACRvB,oBAAIwB,KAAJ,CAAU,0CAAV;AACA;iDACOP,IAAIF,IAAJ,E;;;;AAGTf,oBAAIyB,IAAJ,CAAS,4BAAT,EAAuCR,IAAIC,KAA3C,EAAkD,GAAlD,EAAuDD,IAAIE,GAA3D;AACIO,sB,gBACCT,IAAIJ,O;AACPJ,6BAAWQ,IAAIC,K;AACfR,2BAASO,IAAIE;;;AAITR,wB,GAAWM,IAAIN,Q;AAEfgB,uB,GAAUV,IAAIL,SAAJ,IAAiB,W;AAC3BM,qB,GAAQU,KAAKC,GAAL,E;;uBACOlB,SAASmB,aAAT,CAAuBH,OAAvB,EAAgCD,MAAhC,C;;;AAAfK,sB;;;AAEJ;AACAA,uBAAOC,IAAP,CAAY,UAACC,CAAD,EAAGC,CAAH,EAAO;AACjB,sBAAIC,OAAOF,EAAEG,WAAF,GAAgBF,EAAEE,WAA7B;AACA,sBAAGD,IAAH,EAAS;AACP,2BAAOA,IAAP;AACD;AACD,yBAAOF,EAAEI,gBAAF,GAAqBH,EAAEG,gBAA9B;AACD,iBAND;;AAQA;AACIC,uB,GAAUC,eAAeR,MAAf,C;;;AAEd/B,oBAAIyB,IAAJ,CAAS,WAAT,EAAsBM,OAAOS,MAA7B,EAAqC,WAArC,EAAmDZ,KAAKC,GAAL,KAAWX,KAA9D,EAAqE,IAArE;;;AAIMuB,sB,GAASC,iBAAEC,MAAF,CAASL,OAAT,C;;AACbtC,oBAAI4C,KAAJ,CAAU,SAAV,EAAqBH,OAAOD,MAA5B,EAAoC,oBAApC;AACA;AACQK,iB,GAAE,C;;;sBAAEA,IAAEJ,OAAOD,M;;;;;AACfN,iB,GAAIO,OAAOI,CAAP,C;AACR;;;uBACMrC,GAAG,IAAH,EAAS0B,EAAEY,YAAX,C;;;AAHoB,kBAAED,C;;;;;;;;;;;;AAM9B7C,oBAAIwB,KAAJ,CAAU,qBAAV;;;sBAICP,IAAII,QAAJ,GAAeJ,IAAIE,G;;;;;AACpB;AACI4B,oB,gBACC9B,G;;AAEH;AACAC,yBAAOD,IAAIE,GAAJ,GAAQ,C;;AAEf;AACAA,uBAAKF,IAAIE,GAAJ,GAAU,CAAV,GAAc6B,KAAKC,IAAL,CAAUhC,IAAIG,SAAd;;;;AAGrBpB,oBAAI4C,KAAJ,CAAU,4BAAV,EAAwCG,IAAxC;iDACO,KAAKzB,OAAL,CAAayB,IAAb,EAAmBvC,EAAnB,C;;;AAEPR,oBAAI4C,KAAJ,CAAU,uBAAV;AACA;AACA3B,oBAAIF,IAAJ;;;;;;;;;;qBAOC,YAAEmC,OAAF,CAAUC,QAAV,CAAmB,wBAAnB,C;;;;;AACDnD,oBAAIyB,IAAJ,CAAS,2BAAT;;sBACGF,QAAQ,C;;;;;;;;AAKX;AACI6B,uB,GAAUJ,KAAKC,IAAL,CAAU1B,OAAK,CAAf,C;;AAEd;;sBACG6B,YAAY,C;;;;;;;;iDAKR,KAAK9B,OAAL,cACFL,GADE;AAELG,6BAAWgC,OAFN;AAGLjC,uBAAKiC,UAAUnC,IAAIC;AAHd,oBAIJV,EAJI,C;;;AAMPR,oBAAIwB,KAAJ,CAAU,wBAAV;AACAP,oBAAID,GAAJ;;;;;;;;;;;;;;;;;;;;;kBAnJab,oB;;;AAyJrB,IAAMoC,iBAAiB,SAAjBA,cAAiB,CAACR,MAAD,EAAY;AACjC,SAAOA,OAAOsB,MAAP,CAAc,UAACC,CAAD,EAAGC,CAAH,EAAO;AAC1B,QAAIC,UAAUD,EAAEE,YAAhB;AACAf,qBAAEgB,IAAF,CAAOF,OAAP,EAAgBnD,OAAhB,CAAwB,aAAG;AACzB,UAAIsD,IAAIH,QAAQI,CAAR,CAAR;AACA,UAAGD,EAAEE,WAAF,KAAkB,WAArB,EAAkC;AAChCL,gBAAQI,CAAR,IAAaD,EAAEG,QAAF,EAAb;AACD;AACF,KALD;AAMA,QAAIC,QAAQT,EAAEC,EAAEnB,WAAJ,KAAoB,IAAI4B,iBAAJ,CAAa;AAC3CC,cAAQV,EAAEnB;AADiC,KAAb,CAAhC;AAGA2B,UAAMG,QAAN,CAAeX,CAAf;AACAD,MAAEC,EAAEnB,WAAJ,IAAmB2B,KAAnB;AACA,WAAOT,CAAP;AACD,GAdM,EAcL,EAdK,CAAP;AAeD,CAhBD","file":"StatelessEventPuller.js","sourcesContent":["import Log from 'stream-logger';\nimport EthBlock from 'eth-data';\nimport _ from 'lodash';\n\nconst log = new Log({component: \"StatelessEventPuller\"});\n\nexport default class StatelessEventPuller {\n  constructor(props) {\n    [\n      'pullEvents',\n      '_doPull'\n    ].forEach(fn=>this[fn]=this[fn].bind(this));\n  }\n\n  pullEvents({\n    fromBlock,\n    toBlock,\n    contract,\n    eventName,\n    options\n  }, cb) {\n    return new Promise((done,err)=>{\n      let ctx = {\n        //starting block to pull events from\n        start: fromBlock,\n\n        //ending block range\n        end: toBlock,\n\n        //optional specific event name to pull\n        eventName,\n\n        //same options you can pass to contract getPastEvents\n        options,\n\n        //contract to pull events from\n        contract,\n\n        //all finished callback\n        done,\n\n        //any problems callback\n        err,\n\n        //any split increments to apply as we work towards end block\n        increment: 0,\n\n        //ultimately where to stop regardless of page splitting\n        finalEnd: toBlock\n      };\n\n      this._doPull(ctx, cb);\n    })\n  }\n\n  async _doPull(ctx, cb) {\n    let span = ctx.end - ctx.start;\n    if(span < 0) {\n      log.error(\"Invalid block range. Start is before end\");\n      //return ctx.err(new Error(\"Start block is after end block\"));\n      return ctx.done();\n    }\n\n    log.info(\"Querying for logs in range\", ctx.start, \"-\", ctx.end);\n    let config = {\n      ...ctx.options,\n      fromBlock: ctx.start,\n      toBlock: ctx.end\n    };\n\n    try {\n      let contract = ctx.contract;\n\n      let evtName = ctx.eventName || \"allEvents\";\n      let start = Date.now();\n      let events = await contract.getPastEvents(evtName, config);\n\n      //always make sure events are sorted by block and txn index\n      events.sort((a,b)=>{\n        let diff = a.blockNumber - b.blockNumber;\n        if(diff) {\n          return diff;\n        }\n        return a.transactionIndex - b.transactionIndex;\n      });\n\n      //convert to consistent block structure\n      let byBlock = byBlockAndHash(events);\n\n      log.info(\"Retrieved\", events.length, \"events in\", (Date.now()-start),\"ms\");\n\n      try {\n\n        let blocks = _.values(byBlock);\n        log.debug(\"Sending\", blocks.length, \"blocks to callback\");\n        //for each block\n        for(let i=0;i<blocks.length;++i) {\n          let b = blocks[i];\n          //send back all transaction bundles\n          await cb(null, b.transactions);\n        }\n      } catch (e) {\n        log.error(\"Problem in callback\", e);\n      }\n\n      //if there is more in the entire block range\n      if(ctx.finalEnd > ctx.end) {\n        //split into sub-query\n        let next = {\n          ...ctx,\n\n          //new start is 1 past current end\n          start: ctx.end+1,\n\n          //new end is next increment in range\n          end: ctx.end + 1 + Math.ceil(ctx.increment)\n        };\n\n        log.debug(\"Going to next pull segment\", next);\n        return this._doPull(next, cb)\n      } else {\n        log.debug(\"Finished all segments\");\n        //otherwise scan is complete\n        ctx.done();\n      }\n\n    } catch (e) {\n\n      //yes, hacky, but Infura docs specific have this as what to look\n      //for to adjust block range\n      if(e.message.includes(\"more than 1000 results\")) {\n        log.info(\"Have to split query apart\");\n        if(span <= 1) {\n          //we've already reduced it as much as we can reduce\n          //the span so have to bail out.\n          throw e;\n        }\n        //otherwise, cut the span in 1/2 and try again\n        let newSpan = Math.ceil(span/2);\n\n        //if wec can't split any lower than 1, we bail\n        if(newSpan === 0) {\n          throw e;\n        }\n\n        //recursive call to get new range\n        return this._doPull({\n          ...ctx,\n          increment: newSpan,\n          end: newSpan + ctx.start\n        }, cb);\n      } else {\n        log.error(\"Problem pulling events\", e);\n        ctx.err(e);\n      }\n    }\n  }\n}\n\nconst byBlockAndHash = (events) => {\n  return events.reduce((o,e)=>{\n    let retVals = e.returnValues;\n    _.keys(retVals).forEach(k=>{\n      let d = retVals[k];\n      if(d._ethersType === 'BigNumber') {\n        retVals[k] = d.toString();\n      }\n    });\n    let block = o[e.blockNumber] || new EthBlock({\n      number: e.blockNumber\n    });\n    block.addEvent(e);\n    o[e.blockNumber] = block;\n    return o;\n  },{});\n}\n"]}