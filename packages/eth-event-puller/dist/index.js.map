{"version":3,"sources":["../src/index.js"],"names":["log","Log","component","EventPuller","props","forEach","fn","bind","cb","fromBlock","toBlock","contract","eventName","options","Promise","done","err","ctx","start","end","increment","finalEnd","_doPull","span","info","config","address","evtName","Date","now","getPastEvents","events","sort","a","b","diff","blockNumber","transactionIndex","byBlock","byBlockAndHash","length","debug","blocks","_","values","i","bundles","error","next","Math","ceil","message","includes","newSpan","reduce","o","e","retVals","returnValues","keys","d","k","_ethersType","toString","block","EthBlock","number","addEvent"],"mappings":"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","file":"index.js","sourcesContent":["import Log from 'stream-logger';\nimport EthBlock from 'eth-data';\nimport _ from 'lodash';\n\nconst log = new Log({component: \"EventPuller\"});\n\nexport default class EventPuller {\n  constructor(props) {\n    [\n      'pullEvents',\n      '_doPull'\n    ].forEach(fn=>this[fn]=this[fn].bind(this));\n  }\n\n  pullEvents({\n    fromBlock,\n    toBlock,\n    contract,\n    eventName,\n    options\n  }, cb) {\n    return new Promise((done,err)=>{\n      let ctx = {\n        start: fromBlock,\n        end: toBlock,\n        eventName,\n        options,\n        contract,\n        done,\n        err,\n        increment: 0,\n        finalEnd: toBlock\n      };\n      this._doPull(ctx, cb);\n    })\n  }\n\n  async _doPull(ctx, cb) {\n    let span = ctx.end - ctx.start;\n    log.info(\"Querying for logs in range\", ctx.start, \"-\", ctx.end);\n    let config = {\n      ...ctx.options,\n      fromBlock: ctx.start,\n      toBlock: ctx.end,\n      address: this.address\n    };\n\n    try {\n      let contract = ctx.contract;\n\n      let evtName = ctx.eventName || \"allEvents\";\n      let start = Date.now();\n      let events = await contract.getPastEvents(evtName, config);\n      events.sort((a,b)=>{\n        let diff = a.blockNumber - b.blockNumber;\n        if(diff) {\n          return diff;\n        }\n        return a.transactionIndex - b.transactionIndex;\n      });\n\n      let byBlock = byBlockAndHash(events);\n\n      log.info(\"Retrieved\", events.length, \"events in\", (Date.now()-start),\"ms\");\n\n      try {\n        log.debug(\"ByBlock\", byBlock);\n\n        let blocks = _.values(byBlock);\n        log.debug(\"Sending\", blocks.length, \"blocks to callback\");\n        for(let i=0;i<blocks.length;++i) {\n          let b = blocks[i];\n          await cb(null, b.bundles);\n        }\n      } catch (e) {\n        log.error(\"Problem in callback\", e);\n      }\n\n      if(ctx.finalEnd > ctx.end) {\n        //means we had to split into sub-queries\n        let next = {\n          ...ctx,\n          start: ctx.end+1,\n          end: ctx.end + 1 + Math.ceil(ctx.increment)\n        };\n        log.debug(\"Going to next pull segment\", next);\n        return this._doPull(next, cb)\n\n      } else {\n        log.debug(\"Finished all segments\");\n        ctx.done();\n      }\n\n    } catch (e) {\n      log.error(\"Problem in event puller\", e);\n      \n      if(e.message.includes(\"more than 1000 results\")) {\n        log.info(\"Have to split query apart\");\n        if(span <= 1) {\n          //we've already reduced it as much as we can reduce\n          //the span so have to bail out.\n          throw e;\n        }\n        //otherwise, cut the span in 1/2 and try again\n        let newSpan = Math.ceil(span/2);\n        if(newSpan === 0) {\n          throw e;\n        }\n\n        if(newSpan + ctx.start === ctx.start) {\n          throw e;\n        }\n\n        return this._doPull({\n          ...ctx,\n          increment: newSpan,\n          end: newSpan + ctx.start\n        }, cb);\n      } else {\n        log.error(\"Problem pulling events\", e);\n        ctx.err(e);\n      }\n    }\n  }\n}\n\nconst byBlockAndHash = (events) => {\n  return events.reduce((o,e)=>{\n    let retVals = e.returnValues;\n    _.keys(retVals).forEach(k=>{\n      let d = retVals[k];\n      if(d._ethersType === 'BigNumber') {\n        retVals[k] = d.toString();\n      }\n    });\n    let block = o[e.blockNumber] || new EthBlock({\n      number: e.blockNumber\n    });\n    block.addEvent(e);\n    o[e.blockNumber] = block;\n    return o;\n  },{});\n}\n"]}