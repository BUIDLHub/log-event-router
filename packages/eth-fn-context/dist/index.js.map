{"version":3,"sources":["../src/index.js"],"names":["log","Log","component","FnContext","props","abi","Array","isArray","Error","fnSigs","forEach","a","type","signature","toLowerCase","fn","bind","ctx","Promise","done","err","bundle","txn","input","length","sig","substring","debug","def","fnContext","name"],"mappings":";;;;;;;;AAAA;;;;;;;;AAEA,IAAMA,MAAM,IAAIC,sBAAJ,CAAQ,EAACC,WAAW,WAAZ,EAAR,CAAZ;;IAEqBC,S;AACnB,qBAAYC,KAAZ,EAAmB;AAAA;;AAAA;;AACjB,QAAIC,MAAMD,MAAMC,GAAhB;AACA,QAAG,CAACA,GAAD,IAAQ,CAACC,MAAMC,OAAN,CAAcF,GAAd,CAAZ,EAAgC;AAC9B,YAAM,IAAIG,KAAJ,CAAU,wCAAV,CAAN;AACD;AACD,SAAKC,MAAL,GAAc,EAAd;AACAJ,QAAIK,OAAJ,CAAY,aAAG;;AAEb,UAAGC,EAAEC,IAAF,KAAW,UAAd,EAA0B;AACxB,YAAG,CAACD,EAAEE,SAAN,EAAiB;AACf,gBAAM,IAAIL,KAAJ,CAAU,wCACD,yDADC,GAED,qCAFT,CAAN;AAGD;AACD,cAAKC,MAAL,CAAYE,EAAEE,SAAF,CAAYC,WAAZ,EAAZ,IAAyCH,CAAzC;AACD;AACF,KAVD;AAWA,KACE,SADF,EAEED,OAFF,CAEU;AAAA,aAAI,MAAKK,EAAL,IAAS,MAAKA,EAAL,EAASC,IAAT,CAAc,KAAd,CAAb;AAAA,KAFV;AAGD;;;;4BAEOC,G,EAAK;AAAA;;AACX,aAAO,IAAIC,OAAJ,CAAY,UAACC,IAAD,EAAMC,GAAN,EAAY;AAC7B,YAAIC,SAASJ,IAAII,MAAjB;AACA,YAAIC,MAAMD,OAAOC,GAAjB;AACA,YAAG,CAACA,GAAJ,EAAS;AACP,iBAAOH,KAAKE,MAAL,CAAP;AACD;;AAED,YAAG,CAACC,IAAIC,KAAR,EAAe;AACbJ,eAAKE,MAAL;AACD;;AAED,YAAGC,IAAIC,KAAJ,IAAaD,IAAIC,KAAJ,CAAUC,MAAV,GAAmB,CAAnC,EAAsC;AACpC;AACA,cAAIC,MAAMH,IAAIC,KAAJ,CAAUG,SAAV,CAAoB,CAApB,EAAuB,EAAvB,CAAV;AACA1B,cAAI2B,KAAJ,CAAU,kBAAV,EAA8BF,GAA9B;;AAEA;AACA,cAAIG,MAAM,OAAKnB,MAAL,CAAYgB,GAAZ,CAAV;AACAzB,cAAI2B,KAAJ,CAAU,wBAAV,EAAoCC,GAApC;AACA,cAAGA,GAAH,EAAQ;AACN;AACA;AACA;AACAP,mBAAOQ,SAAP,GAAmBD,IAAIE,IAAvB;AACD,WALD,MAKO;AACL9B,gBAAI2B,KAAJ,CAAU,oBAAV,EAAgCF,GAAhC;AACAJ,mBAAOQ,SAAP,GAAmBJ,GAAnB;AACD;AACF,SAjBD,MAiBO;AACLzB,cAAI2B,KAAJ,CAAU,8BAAV;AACAN,iBAAOQ,SAAP,GAAmB,UAAnB;AACD;AACDV,aAAKE,MAAL;AACD,OAjCM,CAAP;AAkCD;;;;;;kBA1DkBlB,S","file":"index.js","sourcesContent":["import Log from 'stream-logger';\n\nconst log = new Log({component: \"FnContext\"});\n\nexport default class FnContext {\n  constructor(props) {\n    let abi = props.abi;\n    if(!abi || !Array.isArray(abi)) {\n      throw new Error(\"Expected an array of ABI in construtor\");\n    }\n    this.fnSigs = {};\n    abi.forEach(a=>{\n\n      if(a.type === 'function') {\n        if(!a.signature) {\n          throw new Error(\"ABI function is missing signature. \"  +\n                         \"Either hash the fn name and inputs or use eth.Contract \" +\n                         \" to augment ABI with signature data\");\n        }\n        this.fnSigs[a.signature.toLowerCase()] = a;\n      }\n    });\n    [\n      'process'\n    ].forEach(fn=>this[fn]=this[fn].bind(this));\n  }\n\n  process(ctx) {\n    return new Promise((done,err)=>{\n      let bundle = ctx.bundle;\n      let txn = bundle.txn;\n      if(!txn) {\n        return done(bundle);\n      }\n\n      if(!txn.input) {\n        done(bundle);\n      }\n\n      if(txn.input && txn.input.length > 2) {\n        //get the fn signature (4-bytes plus 0x)\n        let sig = txn.input.substring(0, 10);\n        log.debug(\"FnSig from input\", sig);\n\n        //lookup the fn definition by this sig\n        let def = this.fnSigs[sig];\n        log.debug(\"Resolved fn definition\", def);\n        if(def) {\n          //if we found a matching fn, tag the transaction with the\n          //fn's name. This will be used downstream as a context for\n          //all attached log events\n          bundle.fnContext = def.name;\n        } else {\n          log.debug(\"Undefined function\", sig);\n          bundle.fnContext = sig;\n        }\n      } else {\n        log.debug(\"No data input for fn context\");\n        bundle.fnContext = \"no_input\";\n      }\n      done(bundle);\n    });\n  }\n}\n"]}