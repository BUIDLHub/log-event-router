{"version":3,"sources":["../src/EventStream.js"],"names":["yup","schema","object","shape","web3","required","address","string","EventStream","props","validateSync","options","eventName","abi","Array","isArray","Error","contract","eth","Contract","normalizer","EventNormalizer","eventPuller","EventPuller","router","Router","errorHandler","emit","e","forEach","fn","bind","use","arguments","fromBlock","toBlock","cb","block","console","log","process","latest","getBlockNumber","start","span","pullEvents","sub","subscribe","lastBlock","on","number","normalizedBlock","transactions","length","unsubscribe","EventEmitter"],"mappings":"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","file":"EventStream.js","sourcesContent":["import EventEmitter from 'events';\nimport EventNormalizer from './EventNormalizer';\nimport EventPuller from './EventPuller';\nimport Router from './Router';\nimport * as yup from 'yup';\n\nconst schema = yup.object().shape({\n  web3: yup.object().required(\"Missing event stream web3\"),\n  address: yup.string().required(\"Missing contract address for event stream\")\n});\n\nexport default class EventStream extends EventEmitter {\n  constructor(props) {\n    super();\n    schema.validateSync(props);\n\n    //contract address to subscribe to\n    this.address = props.address;\n\n    //web3 impl\n    this.web3 = props.web3;\n\n    //event subscription options (filters mainly)\n    this.options = props.options;\n\n    //specific event to listen for\n    this.eventName = props.eventName;\n\n    //abi for decoding the events\n    let abi = props.abi;\n    if(!Array.isArray(abi)) {\n      throw new Error(\"ABI is expected to be an array of field/event defs\");\n    }\n\n    //creating a contract has a side-effect of adding abi signature to every\n    //function/event definition. We need these later to extract the function\n    //context of event bundles.\n    this.contract = new this.web3.eth.Contract(abi, this.address, {address: this.address});\n\n    //used to pull in transactions that bundle up all events emitted together\n    this.normalizer = new EventNormalizer({\n      abi,\n      web3: this.web3\n    });\n\n    //utility to pull and decode the events\n    this.eventPuller = new EventPuller({\n      abi,\n      options: this.options,\n      eventName: this.eventName,\n      address: this.address,\n      web3: this.web3,\n      normalizer: this.normalizer\n    });\n\n    //utility to distribute txns with bundled events\n    this.router = new Router({errorHandler: e=>this.emit(\"error\", e)});\n\n    [\n      'start',\n      'use',\n      'stop'\n    ].forEach(fn=>this[fn]=this[fn].bind(this));\n  }\n\n  use() {\n    this.router.use(...arguments);\n  }\n\n  /**\n   * Start the stream and start scanning from the fromBlock-toBlock range.\n   * Be sure to install all router handlers  before starting the stream\n   */\n  async start({fromBlock, toBlock}) {\n    if(fromBlock < 0) {\n      fromBlock = 0;\n    }\n\n    //callback for event puller.\n    let cb = async (e, block) => {\n      try {\n        console.log(\"Received block\", block);\n        //route the block to the router for handling\n        await this.router.process({}, block);\n      } catch (e) {\n        console.log(\"Problem routing data\", e);\n        this.emit(\"error\", e);\n      }\n    };\n\n    //first need to recover missed events since last run\n    let latest = toBlock;\n    if(!latest) {\n      //go to the top of the current chain by default\n      latest = await this.web3.eth.getBlockNumber();\n    }\n\n    if(latest < fromBlock) {\n      throw new Error(\"Start block must come before end block: \" + fromBlock + \" > \" + latest);\n    }\n\n    let start = fromBlock;\n    let span = latest - start;\n    console.log(\"Scanning blocks\", start,\"-\",latest);\n\n    //while there is a gap in block scanning\n    while(span > 0) {\n      //pull all events for the span\n      await this.eventPuller.pullEvents({\n        fromBlock: start,\n        toBlock: latest\n      }, cb);\n\n      //reset the start for next iteration\n      start = latest+1;\n\n      //grab the latest right now\n      latest = await this.web3.eth.getBlockNumber();\n\n      //compute new span\n      span = latest - start;\n    }\n\n    console.log(\"Finished recovering past events\");\n\n    //now subscribe to new blocks and trigger event pulls on each\n    //new block\n    this.sub = this.web3.eth.subscribe(\"newBlockHeaders\")\n    let lastBlock = latest;\n    this.sub.on(\"data\", async (block)=>{\n      if(block) {\n        try {\n          console.log(\"Receiving new block\", block.number);\n          //we start from the last block we pulled so that\n          //if there are missing notifications we still pull\n          //all the data\n          let start = lastBlock;\n\n          console.log(\"Pulling events between blocks\",start,\"-\",block.number);\n          await this.eventPuller.pullEvents({\n            fromBlock: start,\n            toBlock: block.number\n          }, async (e, normalizedBlock)=>{\n            if(normalizedBlock.transactions.length > 0) {\n              lastBlock = normalizedBlock.number+1;\n            }\n            try {\n              await this.router.process({}, normalizedBlock);\n            } catch (er) {\n              this.emit(\"error\", er);\n            }\n          });\n        } catch (er) {\n          this.emit(\"error\", er);\n        }\n      }\n    });\n  }\n\n  async stop() {\n    if(this.sub) {\n      await this.sub.unsubscribe();\n      this.sub = null;\n    }\n  }\n}\n"]}