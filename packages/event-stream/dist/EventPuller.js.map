{"version":3,"sources":["../src/EventPuller.js"],"names":["yup","schema","object","shape","address","string","required","web3","normalizer","EventPuller","props","validateSync","abi","options","eventName","contract","eth","Contract","forEach","fn","bind","cb","fromBlock","toBlock","Promise","done","err","ctx","start","end","history","increment","finalEnd","_doPull","span","console","log","config","evtName","Date","now","getPastEvents","events","length","sort","a","b","blockNumber","block","getBlock","fromChain","currentBlock","number","transactions","timestamp","i","evt","_","values","transactionIndex","normalize","next","Math","ceil","message","includes","newSpan"],"mappings":"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","file":"EventPuller.js","sourcesContent":["import * as yup from 'yup';\nimport _ from 'lodash';\n\nconst schema = yup.object().shape({\n  address: yup.string().required(\"Missing contract address\"),\n  web3: yup.object().required(\"Missing web3\"),\n  normalizer: yup.object().required(\"Missing event normalizer\")\n});\n\nexport default class EventPuller {\n  constructor(props) {\n    schema.validateSync(props);\n    this.abi = props.abi;\n    this.web3 = props.web3;\n    this.options = props.options;\n    this.eventName = props.eventName;\n    this.normalizer = props.normalizer;\n    this.address = props.address;\n    this.contract = new this.web3.eth.Contract(this.abi, this.address, {address: this.address});\n    [\n      'pullEvents',\n      '_doPull'\n    ].forEach(fn=>this[fn]=this[fn].bind(this));\n  }\n\n  pullEvents({fromBlock, toBlock}, cb) {\n    return new Promise(async (done,err)=>{\n      let ctx = {\n        start: fromBlock,\n        end: toBlock,\n        history: {},\n        increment: 0,\n        finalEnd: toBlock,\n        done,\n        err\n      };\n      this._doPull(ctx, cb);\n    });\n  }\n\n  async _doPull(ctx, cb) {\n    let span = ctx.end - ctx.start;\n    console.log(\"Querying for logs in range\", ctx.start, \"-\", ctx.end);\n    let config = {\n      ...this.options,\n      fromBlock: ctx.start,\n      toBlock: ctx.end,\n      address: this.address\n    };\n\n    try {\n      let evtName = this.eventName || \"allEvents\";\n      let start = Date.now();\n      let events = await this.contract.getPastEvents(evtName, config);\n      console.log(\"Retrieved\", events.length, \"events in\", (Date.now()-start),\"ms\");\n\n      //make sure we're sorted by ascending block number\n      events.sort((a,b)=>{\n        return a.blockNumber - b.blockNumber\n      });\n\n      //now with sorted blocks, we can normalize and then announce based on\n      //block changes\n      let block = events.length>0?events[0].blockNumber:0;\n      let fromChain = await this.web3.eth.getBlock(block);\n      let currentBlock = {\n        number: block,\n        transactions: [],\n        timestamp: fromChain\n      };\n\n      for(let i=0;i<events.length;++i) {\n        let evt = events[i];\n        evt.timestamp = currentBlock.timestamp;\n\n        if(evt.blockNumber !== block) {\n          fromChain = await this.web3.eth.getBlock(evt.blockNumber);\n\n          //new block, convert what we've built up to transaction set\n          currentBlock.transactions = _.values(ctx.history);\n          //ordered by txn index\n          currentBlock.transactions.sort((a,b)=>{\n            return a.transactionIndex - b.transactionIndex\n          });\n          try {\n            await cb(null, currentBlock);\n          } catch (e) {\n            console.log(\"Problem sending event block to callback\", e);\n          }\n          currentBlock = {\n            number: evt.blockNumber,\n            transactions: [],\n            timestamp: fromChain.timestamp\n          };\n          ctx.history = {};\n          block = evt.blockNumber;\n        }\n        try {\n          console.log(\"Normalizing event's transaction from block: \" + evt.blockNumber);\n          await this.normalizer.normalize(evt,ctx.history);\n          console.log(\"Txn normalized\");\n        } catch (e) {\n          console.log(\"Problem normalizing\", e);\n        }\n\n      }\n\n      if(_.values(ctx.history).length > 0) {\n        //new block, convert what we've built up to transaction set\n        currentBlock.transactions = _.values(ctx.history);\n        //ordered by txn index\n        currentBlock.transactions.sort((a,b)=>{\n          return a.transactionIndex - b.transactionIndex\n        });\n        try {\n          await cb(null, currentBlock);\n        } catch (e) {\n          console.log(\"Problem sending event block to callback\", e);\n        }\n      }\n\n      if(ctx.finalEnd > ctx.end) {\n        //means we had to split into sub-queries\n        let next = {\n          ...ctx,\n          start: ctx.end+1,\n          end: ctx.end + 1 + Math.ceil(ctx.increment)\n        };\n        console.log(\"Going to next pull segment\", next);\n        return this._doPull(next, cb)\n\n      } else {\n        console.log(\"Finished all segments\");\n        ctx.done();\n      }\n\n    } catch (e) {\n      if(e.message.includes(\"more than 1000 results\")) {\n        console.log(\"Have to split query apart\");\n        if(span <= 1) {\n          //we've already reduced it as much as we can reduce\n          //the span so have to bail out.\n          throw e;\n        }\n        //otherwise, cut the span in 1/2 and try again\n        let newSpan = Math.ceil(span/2);\n        if(newSpan === 0) {\n          throw e;\n        }\n\n        if(newSpan + ctx.start === ctx.start) {\n          throw e;\n        }\n\n        return this._doPull({\n          ...ctx,\n          increment: newSpan,\n          end: newSpan + ctx.start\n        }, cb);\n      } else {\n        console.log(\"Problem pulling events\", e);\n        ctx.err(e);\n      }\n    }\n  }\n}\n"]}